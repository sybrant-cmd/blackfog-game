<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>BlackFog TTX – Facilitator</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 0;
      background: #020617;
      color: #e5e7eb;
      display: flex;
      flex-direction: column;
      min-height: 100vh;
    }
    header {
      padding: 12px 20px;
      background: #020617;
      border-bottom: 1px solid #111827;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    header h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .08em;
      text-transform: uppercase;
    }
    header .session {
      font-size: 11px;
      opacity: 0.8;
    }
    main {
      flex: 1;
      padding: 14px 20px 10px;
      display: grid;
      grid-template-columns: 2fr 1.5fr;
      gap: 14px;
    }
    @media (max-width: 900px) {
      main { grid-template-columns: 1fr; }
    }
    .card {
      background: #020617;
      border-radius: 12px;
      border: 1px solid #1f2937;
      padding: 10px 12px;
      box-shadow: 0 14px 35px rgba(0,0,0,.55);
    }
    .card h2 {
      margin: 0 0 6px 0;
      font-size: 13px;
      text-transform: uppercase;
      letter-spacing: .08em;
      color: #9ca3af;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    label {
      font-size: 12px;
      opacity: 0.85;
    }
    input[type="text"], textarea {
      font-family: inherit;
      font-size: 12px;
      background: #020617;
      color: #e5e7eb;
      border-radius: 8px;
      border: 1px solid #374151;
      padding: 4px 6px;
    }
    input[type="text"] { min-width: 120px; }
    textarea {
      width: 100%;
      resize: vertical;
      min-height: 70px;
    }
    button {
      border-radius: 999px;
      border: none;
      padding: 6px 12px;
      font-size: 12px;
      cursor: pointer;
      font-weight: 500;
    }
    button.primary { background: #2563eb; color: #f9fafb; }
    button.secondary { background: #374151; color: #e5e7eb; }
    button:disabled { opacity: .5; cursor: default; }
    .meta {
      font-size: 11px;
      opacity: 0.85;
      margin-top: 4px;
      white-space: pre-wrap;
    }
    .scenario-text {
      font-size: 12px;
      opacity: 0.9;
      margin-top: 6px;
      white-space: pre-wrap;
    }
    .inject-list {
      max-height: 200px;
      overflow-y: auto;
      border-top: 1px dashed #111827;
      margin-top: 6px;
      padding-top: 4px;
    }
    .inject-item {
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 5px 7px;
      border-radius: 8px;
      margin-bottom: 4px;
      background: #020617;
      cursor: pointer;
    }
    .inject-item.current {
      border: 1px solid #2563eb;
      background: radial-gradient(circle at top left, rgba(37,99,235,0.2), #020617 60%);
    }
    .pill {
      font-size: 11px;
      border-radius: 999px;
      padding: 1px 6px;
      background: #111827;
      margin-left: 4px;
    }
    .current-inject {
      white-space: pre-wrap;
      font-size: 13px;
      line-height: 1.45;
    }
    .votes {
      font-size: 12px;
      line-height: 1.5;
    }
    .badge {
      display: inline-block;
      min-width: 22px;
      text-align: center;
      border-radius: 999px;
      padding: 2px 6px;
      background: #020617;
      margin-right: 6px;
    }
    .majority-label {
      font-size: 11px;
      opacity: 0.9;
      margin-top: 4px;
    }
    .players {
      font-size: 12px;
      max-height: 130px;
      overflow-y: auto;
      white-space: pre-wrap;
    }
    #aarBox {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 11px;
      width: 100%;
      min-height: 90px;
    }
    footer {
      padding: 6px 20px 9px;
      border-top: 1px solid #111827;
      background: #020617;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      gap: 8px;
    }
    #ticker {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      opacity: 0.9;
    }
    #footerHint { opacity: 0.7; }
  </style>
</head>
<body>
<header>
  <h1>BLACKFOG TTX – FACILITATOR</h1>
  <div class="session">
    Session: <span id="sessionLabel"></span> · Players: <span id="playerCount"></span>
  </div>
</header>

<main>
  <section>
    <div class="card">
      <h2>Scenario</h2>
      <div class="row">
        <label for="scenarioTitle">Title</label>
        <input type="text" id="scenarioTitle">
        <button class="secondary" id="loadScenarioBtn">Load template</button>
      </div>
      <div class="row">
        <textarea id="scenarioDescription" placeholder="Scenario summary..."></textarea>
      </div>
      <div class="row">
        <button class="secondary" id="saveScenarioBtn">Save / update scenario text</button>
        <button class="primary" id="startSessionBtn">Start exercise</button>
        <button class="secondary" id="endSessionBtn">End session</button>
        <button class="secondary" id="resetSessionBtn">Reset session</button>
      </div>
      <div id="scenarioText" class="scenario-text"></div>
      <div id="runStatus" class="meta">No scenario loaded yet.</div>
    </div>

    <div class="card">
      <h2>Injects</h2>
      <div class="row">
        <label for="injectTime">Time</label>
        <input type="text" id="injectTime" placeholder="T+00m">
        <label for="injectPhase">Phase</label>
        <input type="text" id="injectPhase" placeholder="Intel / Detection / Containment...">
        <label for="injectSeverity">Severity</label>
        <input type="text" id="injectSeverity" placeholder="Medium / High / Critical">
      </div>
      <div class="row">
        <textarea id="injectNarrative" placeholder="Narrative..."></textarea>
      </div>
      <div class="row">
        <input type="text" id="decisionQuestion" placeholder="Decision question (optional)" style="flex:1;">
      </div>
      <div class="row">
        <input type="text" id="optA" placeholder="Option A" style="flex:1;">
      </div>
      <div class="row">
        <input type="text" id="optB" placeholder="Option B" style="flex:1;">
      </div>
      <div class="row">
        <input type="text" id="optC" placeholder="Option C" style="flex:1;">
      </div>
      <div class="row">
        <button class="secondary" id="updateInjectBtn">Save changes to selected inject</button>
        <button class="primary" id="sendNextBtn" disabled>Send next inject</button>
      </div>
      <div id="injectList" class="inject-list"></div>
    </div>

    <div class="card">
      <h2>Current Inject</h2>
      <div id="currentInjectBox" class="current-inject">No inject sent yet.</div>
    </div>
  </section>

  <section>
    <div class="card">
      <h2>Votes</h2>
      <div id="votesBox" class="votes">No votes yet.</div>
    </div>

    <div class="card">
      <h2>Players</h2>
      <div id="playersBox" class="players">Waiting for players…</div>
    </div>

    <div class="card">
      <h2>AAR</h2>
      <textarea id="aarBox" readonly>Click "Build AAR" after running through the injects.</textarea>
      <div class="row" style="margin-top:6px;">
        <button class="secondary" id="buildAarBtn">Build AAR</button>
        <button class="secondary" id="broadcastAarBtn">Broadcast AAR</button>
      </div>
    </div>
  </section>
</main>

<footer>
  <div id="ticker">Ready. Click "Load template" to push scenario + injects to this session.</div>
  <div id="footerHint">Players join via <code>player.html?s=&lt;session_id&gt;</code></div>
</footer>

<script type="module">
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
  import {
    getDatabase, ref, set, update, onValue
  } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js";

  // Your existing Firebase project
  const firebaseConfig = {
    apiKey: "AIzaSyBjnfJOD8bK-PLKiFOYzC8Yz2S7g1hM1W0",
    authDomain: "rws-blackfog-game.firebaseapp.com",
    databaseURL: "https://rws-blackfog-game-default-rtdb.asia-southeast1.firebasedatabase.app",
    projectId: "rws-blackfog-game",
    storageBucket: "rws-blackfog-game.firebasestorage.app",
    messagingSenderId: "473543964029",
    appId: "1:473543964029:web:4bc0db33634ed2f8894814"
  };

  // ONE hardcoded scenario + inject pack (you can add more later)
  const templateScenario = {
    title: "Hospitality Operations Disruption & Ransomware",
    description:
      "A mix of social engineering and weak access controls leads to disruption across room, payment and loyalty systems, ending in ransomware.",
    injects: [
      {
        seq: 1,
        time: "T+00m",
        phase: "Intel",
        severity: "Medium",
        narrative:
          "Service desk receives a call from someone claiming to be from infrastructure, asking for a password reset on a shared admin ID used by property systems.",
        decision: {
          question: "What should the service desk do?",
          options: {
            A: "Enforce strict verification and refuse until identity is confirmed.",
            B: "Reset quickly to be helpful and keep systems running.",
            C: "Reset and email the shared mailbox afterwards."
          }
        }
      },
      {
        seq: 2,
        time: "T+1d",
        phase: "Detection",
        severity: "High",
        narrative:
          "Room key and check-in systems show intermittent failures at multiple sites. Staff are falling back to manual processes and queues are building.",
        decision: {
          question: "How should technology teams respond?",
          options: {
            A: "Declare an incident with operations and central IT immediately.",
            B: "Ask each site to reboot servers and observe.",
            C: "Treat it as likely vendor instability and wait."
          }
        }
      },
      {
        seq: 3,
        time: "T+1d+4h",
        phase: "Containment",
        severity: "Critical",
        narrative:
          "Ransom notes appear on key hospitality and loyalty servers. Some file shares are encrypted. There are traces of credential dumping and lateral movement.",
        decision: {
          question: "What containment approach makes sense?",
          options: {
            A: "Segment and disconnect affected networks quickly, accepting guest impact.",
            B: "Contain only obviously affected servers for now.",
            C: "Delay major moves until ransom note is fully analysed."
          }
        }
      }
    ]
  };

  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  const params = new URLSearchParams(location.search);
  const sessionId = params.get("s") || "default";
  document.getElementById("sessionLabel").textContent = sessionId;

  const scenarioRef     = ref(db, "sessions/" + sessionId + "/scenario");
  const injectsRef      = ref(db, "sessions/" + sessionId + "/injects");
  const latestInjectRef = ref(db, "sessions/" + sessionId + "/latestInject");
  const playersRef      = ref(db, "sessions/" + sessionId + "/players");
  const votesRef        = ref(db, "sessions/" + sessionId + "/votes");
  const aarRef          = ref(db, "sessions/" + sessionId + "/aar");

  const scenarioTitleEl  = document.getElementById("scenarioTitle");
  const scenarioDescEl   = document.getElementById("scenarioDescription");
  const scenarioTextEl   = document.getElementById("scenarioText");
  const runStatusEl      = document.getElementById("runStatus");
  const injectTimeEl     = document.getElementById("injectTime");
  const injectPhaseEl    = document.getElementById("injectPhase");
  const injectSeverityEl = document.getElementById("injectSeverity");
  const injectNarrativeEl= document.getElementById("injectNarrative");
  const decisionQuestionEl = document.getElementById("decisionQuestion");
  const optAEl           = document.getElementById("optA");
  const optBEl           = document.getElementById("optB");
  const optCEl           = document.getElementById("optC");
  const injectListEl     = document.getElementById("injectList");
  const currentInjectBox = document.getElementById("currentInjectBox");
  const votesBox         = document.getElementById("votesBox");
  const playersBox       = document.getElementById("playersBox");
  const playerCountEl    = document.getElementById("playerCount");
  const aarBox           = document.getElementById("aarBox");
  const tickerEl         = document.getElementById("ticker");

  const loadScenarioBtn  = document.getElementById("loadScenarioBtn");
  const saveScenarioBtn  = document.getElementById("saveScenarioBtn");
  const startSessionBtn = document.getElementById("startSessionBtn");
  const endSessionBtn   = document.getElementById("endSessionBtn");
  const resetSessionBtn = document.getElementById("resetSessionBtn");
  const updateInjectBtn  = document.getElementById("updateInjectBtn");
  const sendNextBtn      = document.getElementById("sendNextBtn");
  const buildAarBtn      = document.getElementById("buildAarBtn");
  const broadcastAarBtn  = document.getElementById("broadcastAarBtn");

  let injects   = [];
  let currentSeq = null;
  let editorSeq  = null;
  let votesBySeq = {};
  let scenarioStatus = "idle";
  let tickerMessages = [];
  let tickerIndex = 0;
  const cyberNews = [
    "Global hospitality group reports ransomware activity affecting booking and payment systems.",
    "Phishing campaigns continue to target service desk and IT support staff in large enterprises.",
    "Zero-day vulnerabilities in widely used VPN appliances highlight importance of patch management.",
    "Ransomware operators increasingly use data theft and extortion before encryption.",
    "Multi-factor authentication fatigue attacks observed across multiple sectors, including hospitality.",
    "Regulators remind organisations to document incident response and customer communication plans."
  ];

  function pushTicker(msg) {
    const ts = new Date().toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
    tickerMessages.unshift("[" + ts + "] " + msg);
    if (tickerMessages.length > 25) tickerMessages.length = 25;
  }

  function startTicker() {
    if (tickerMessages.length === 0) {
      tickerMessages = cyberNews.slice();
    }
    setInterval(() => {
      if (tickerMessages.length === 0) {
        tickerEl.textContent = 'Ready. Click "Load template" to push scenario + injects to this session.';
        return;
      }
      tickerIndex = (tickerIndex + 1) % tickerMessages.length;
      tickerEl.textContent = tickerMessages[tickerIndex];
    }, 6000);
  }

  function computeTallyForSeq(seq) {
    const votes = votesBySeq[seq] || {};
    const tally = { A: 0, B: 0, C: 0 };
    Object.values(votes).forEach(v => {
      if (v.choice === "A") tally.A++;
      else if (v.choice === "B") tally.B++;
      else if (v.choice === "C") tally.C++;
    });
    return tally;
  }

  function computeMajority(tally) {
    const arr = [["A", tally.A], ["B", tally.B], ["C", tally.C]];
    arr.sort((a,b) => b[1] - a[1]);
    if (arr[0][1] === 0) return null;
    const top = arr[0][1];
    const ties = arr.filter(x => x[1] === top).length;
    return ties > 1 ? null : arr[0][0];
  }

  function renderScenarioText(sc) {
    if (!sc) {
      scenarioTextEl.textContent = "";
      runStatusEl.textContent = "No scenario loaded yet.";
      return;
    }
    scenarioTextEl.textContent = (sc.title || "") + "\\n\\n" + (sc.description || "");
    if (injects.length === 0) {
      runStatusEl.textContent = "Scenario loaded. No injects?";
    } else if (currentSeq == null) {
      runStatusEl.textContent = "Scenario loaded. Injects: " + injects.length + ". Click \"Send next inject\".";
    } else {
      const idx = injects.findIndex(i => i.seq === currentSeq);
      runStatusEl.textContent = "Inject " + (idx + 1) + " of " + injects.length + " is current.";
    }
  }

  function loadEditorFromInject(inj) {
    if (!inj) {
      editorSeq = null;
      injectTimeEl.value = "";
      injectPhaseEl.value = "";
      injectSeverityEl.value = "";
      injectNarrativeEl.value = "";
      decisionQuestionEl.value = "";
      optAEl.value = "";
      optBEl.value = "";
      optCEl.value = "";
      return;
    }
    editorSeq = inj.seq;
    injectTimeEl.value = inj.time || "";
    injectPhaseEl.value = inj.phase || "";
    injectSeverityEl.value = inj.severity || "";
    injectNarrativeEl.value = inj.narrative || "";
    const dec  = inj.decision || {};
    const opts = dec.options || {};
    decisionQuestionEl.value = dec.question || "";
    optAEl.value = opts.A || "";
    optBEl.value = opts.B || "";
    optCEl.value = opts.C || "";
  }

  function renderInjectList() {
    injectListEl.innerHTML = "";
    if (injects.length === 0) {
      injectListEl.textContent = "No injects.";
      sendNextBtn.disabled = true;
      return;
    }
    injects.forEach(inj => {
      const div = document.createElement("div");
      div.className = "inject-item" + (inj.seq === currentSeq ? " current" : "");
      const left = document.createElement("div");
      left.textContent = "#" + inj.seq + " " + (inj.phase || "");
      const right = document.createElement("div");
      right.innerHTML = "<span class='pill'>" + (inj.time || "") + "</span>";
      div.appendChild(left);
      div.appendChild(right);
      div.onclick = () => {
        loadEditorFromInject(inj);
        renderCurrentInject();
      };
      injectListEl.appendChild(div);
    });
    sendNextBtn.disabled = false;
  }

  function renderCurrentInject() {
    if (currentSeq == null) {
      currentInjectBox.textContent = "No inject sent yet.";
      votesBox.textContent = "No votes yet.";
      return;
    }
    const inj = injects.find(i => i.seq === currentSeq);
    if (!inj) {
      currentInjectBox.textContent = "No inject sent yet.";
      votesBox.textContent = "No votes yet.";
      return;
    }
    const lines = [];
    lines.push((inj.time || "") + " • " + (inj.phase || ""));
    if (inj.severity) lines.push(inj.severity);
    lines.push("");
    lines.push(inj.narrative || "");
    if (inj.decision && inj.decision.question) {
      lines.push("");
      lines.push("Decision: " + inj.decision.question);
      const opts = inj.decision.options || {};
      if (opts.A) lines.push("  A. " + opts.A);
      if (opts.B) lines.push("  B. " + opts.B);
      if (opts.C) lines.push("  C. " + opts.C);
    }
    currentInjectBox.textContent = lines.join("\\n");

    const tally    = computeTallyForSeq(currentSeq);
    const majority = computeMajority(tally);
    votesBox.innerHTML =
      "<div><span class='badge'>A</span>" + tally.A + "</div>" +
      "<div><span class='badge'>B</span>" + tally.B + "</div>" +
      "<div><span class='badge'>C</span>" + tally.C + "</div>" +
      "<div class='majority-label'>Majority: " + (majority || "None / Split") + "</div>";
  }

  function renderPlayers(snapshot) {
    const now = Date.now();
    const lines = [];
    let active = 0;
    let total  = 0;
    snapshot.forEach(child => {
      total++;
      const v   = child.val() || {};
      const ts  = v.ts || 0;
      const age = now - ts;
      const online = v.status === "online" && age < 90000;
      if (online) active++;
      const label = online ? "online" : (v.status || "inactive");
      lines.push((v.name || child.key) + " (" + label + ", " + Math.round(age/1000) + "s)");
    });
    if (total === 0) {
      playersBox.textContent = "Waiting for players…";
      playerCountEl.textContent = "0";
    } else {
      playersBox.textContent = lines.join("\\n");
      playerCountEl.textContent = active + " / " + total;
    }
  }

  function sendNextInject() {
    if (injects.length === 0) return;
    let seqToSend = null;
    if (currentSeq == null) {
      seqToSend = injects[0].seq;
    } else {
      const idx = injects.findIndex(i => i.seq === currentSeq);
      if (idx >= 0 && idx < injects.length - 1) {
        seqToSend = injects[idx + 1].seq;
      }
    }
    if (seqToSend == null) {
      pushTicker("Already at last inject.");
      return;
    }
    const inj = injects.find(i => i.seq === seqToSend);
    if (!inj) return;
    currentSeq = seqToSend;
    set(latestInjectRef, inj);
    pushTicker("Inject #" + seqToSend + " sent.");
    renderInjectList();
    renderCurrentInject();
  }

  function buildAAR() {
    if (injects.length === 0) {
      aarBox.value = "No injects.";
      return;
    }
    const lines = [];
    lines.push("=== After-Action Review ===");
    lines.push("");
    let proactive = 0, cautious = 0, delayed = 0, noVotes = 0;

    injects.forEach(inj => {
      const tally    = computeTallyForSeq(inj.seq);
      const majority = computeMajority(tally);
      lines.push("Inject #" + inj.seq + " [" + (inj.time || "") + " | " + (inj.phase || "") + "]");
      lines.push("Narrative: " + (inj.narrative || ""));
      if (inj.decision && inj.decision.question) {
        lines.push("Decision: " + inj.decision.question);
        const opts = inj.decision.options || {};
        if (opts.A) lines.push("  A. " + opts.A);
        if (opts.B) lines.push("  B. " + opts.B);
        if (opts.C) lines.push("  C. " + opts.C);
      }
      const total = tally.A + tally.B + tally.C;
      lines.push("Votes → A: " + tally.A + "  B: " + tally.B + "  C: " + tally.C);
      lines.push("Majority: " + (majority || "None / Split"));
      lines.push("");

      if (total === 0)      noVotes++;
      else if (majority==="A") proactive++;
      else if (majority==="B") cautious++;
      else if (majority==="C") delayed++;
    });

    lines.push("--- Overall pattern ---");
    lines.push("Proactive (A-majority) decisions: " + proactive);
    lines.push("Cautious / wait (B-majority) decisions: " + cautious);
    lines.push("Delay / least action (C-majority) decisions: " + delayed);
    lines.push("Injects with no votes: " + noVotes);
    lines.push("");
    lines.push("Use this as a neutral starting point for your own discussion.");

    aarBox.readOnly = false;
    aarBox.value = lines.join("\\n");
    pushTicker("AAR built locally.");
  }

  function broadcastAAR() {
    const text = aarBox.value || "";
    set(aarRef, { text, ts: Date.now() })
      .then(() => pushTicker("AAR broadcast to players."))
      .catch(console.error);
  }

  // Handlers
  loadScenarioBtn.onclick = () => {
    // Seed scenario + injects from template
    const scen = {
      title: templateScenario.title,
      description: templateScenario.description,
      status: "configured"
    };
    set(scenarioRef, scen);
    const injMap = {};
    templateScenario.injects.forEach(inj => injMap[inj.seq] = inj);
    set(injectsRef, injMap);
    set(latestInjectRef, null);
    set(votesRef, null);
    set(aarRef, null);
    currentSeq = null;
    editorSeq  = null;
    scenarioTitleEl.value = scen.title;
    scenarioDescEl.value  = scen.description;
    pushTicker("Template scenario loaded into session.");
  };

  saveScenarioBtn.onclick = () => {
    const title = scenarioTitleEl.value.trim();
    const desc  = scenarioDescEl.value.trim();
    if (!title) {
      alert("Scenario title is required.");
      return;
    }
    update(scenarioRef, { title, description: desc })
      .then(() => pushTicker("Scenario text updated."))
      .catch(console.error);
  };

  startSessionBtn.onclick = () => {
    update(scenarioRef, { status: "started", startedAt: Date.now() })
      .then(() => pushTicker("Session started."))
      .catch(console.error);
  };

  endSessionBtn.onclick = () => {
    update(scenarioRef, { status: "ended", endedAt: Date.now() })
      .then(() => pushTicker("Session ended."))
      .catch(console.error);
  };

  resetSessionBtn.onclick = () => {
    Promise.all([
      set(scenarioRef, null),
      set(injectsRef, null),
      set(latestInjectRef, null),
      set(votesRef, null),
      set(aarRef, null)
    ]).then(() => {
      injects = [];
      currentSeq = null;
      editorSeq = null;
      votesBySeq = {};
      scenarioStatus = "idle";
      scenarioTitleEl.value = "";
      scenarioDescEl.value = "";
      scenarioTextEl.textContent = "";
      runStatusEl.textContent = "Session reset. Click \"Load template\" to configure again.";
      pushTicker("Session data cleared for this session id.");
    }).catch(console.error);
  };

  updateInjectBtn.onclick = () => {updateInjectBtn.onclick = () => {
    if (editorSeq == null) {
      alert("Select an inject (click in list) before saving.");
      return;
    }
    const time   = injectTimeEl.value.trim();
    const phase  = injectPhaseEl.value.trim();
    const sev    = injectSeverityEl.value.trim();
    const narr   = injectNarrativeEl.value.trim();
    const q      = decisionQuestionEl.value.trim();
    const a      = optAEl.value.trim();
    const b      = optBEl.value.trim();
    const c      = optCEl.value.trim();
    if (!narr) {
      alert("Narrative is required.");
      return;
    }
    const inj = { seq: editorSeq, time: time, phase: phase, severity: sev, narrative: narr };
    if (q || a || b || c) {
      inj.decision = { question: q, options: { A: a, B: b, C: c } };
    }
    set(ref(db, "sessions/" + sessionId + "/injects/" + editorSeq), inj)
      .then(() => pushTicker("Inject #" + editorSeq + " updated."))
      .catch(console.error);
  };

  sendNextBtn.onclick    = sendNextInject;
  buildAarBtn.onclick    = buildAAR;
  broadcastAarBtn.onclick= broadcastAAR;

  // Listeners
  onValue(scenarioRef, snap => {
    const sc = snap.val();
    if (sc) {
      scenarioTitleEl.value = sc.title || "";
      scenarioDescEl.value  = sc.description || "";
    }
    renderScenarioText(sc);
  });

  onValue(injectsRef, snap => {
    const arr = [];
    snap.forEach(child => {
      const v = child.val();
      if (!v) return;
      v.seq = Number(v.seq || child.key);
      arr.push(v);
    });
    arr.sort((a,b) => (a.seq || 0) - (b.seq || 0));
    injects = arr;
    renderScenarioText(snap.exists() ? { title: scenarioTitleEl.value, description: scenarioDescEl.value } : null);
    renderInjectList();
    if (injects.length && editorSeq == null) {
      loadEditorFromInject(injects[0]);
    }
    renderCurrentInject();
  });

  onValue(playersRef, snap => renderPlayers(snap));

  onValue(votesRef, snap => {
    const bySeq = {};
    snap.forEach(seqSnap => {
      const seq = Number(seqSnap.key);
      const inner = {};
      seqSnap.forEach(voteSnap => inner[voteSnap.key] = voteSnap.val());
      bySeq[seq] = inner;
    });
    votesBySeq = bySeq;
    renderCurrentInject();
  });

  onValue(latestInjectRef, snap => {
    const inj = snap.val();
    if (!inj) {
      currentSeq = null;
      renderCurrentInject();
      return;
    }
    currentSeq = Number(inj.seq || currentSeq);
    renderInjectList();
    renderCurrentInject();
  });

  startTicker();
</script>
</body>
</html>
